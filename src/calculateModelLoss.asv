function loss = calculateModelLoss(param_vec)

global mcmcInfo

n_chains = mcmcInfo.n_chains;

mcmcInfo.k_curr = param_vec(1:3);
mcmcInfo.k_curr(end) = exp(mcmcInfo.k_curr(end));
mcmcInfo.r_curr = param_vec(4:5);
mcmcInfo.r_curr(end) = exp(mcmcInfo.r_curr(end
mcmcInfo.sigma_curr = repmat(param_vec(end),n_chains,1);

% generate full variable arrays
Q_init = Q_helper_fun(mcmcInfo.k_curr(1),mcmcInfo.k_curr(2),mcmcInfo.k_curr(3));
mcmcInfo.A_curr = repmat(expm(Q_init*mcmcInfo.tres),1,1,n_chains);
r_vec = [0 mcmcInfo.r_curr'];

% calculate pi0 
[V, D] = eig(mcmcInfo.A_curr(:,:,1));
[~, mi] = max(real(diag(D)));
mcmcInfo.pi0_curr = repmat((V(:,mi)/sum(V(:,mi)))',n_chains,1);    

mcmcInfo.v_curr = repmat(r_vec*mcmcInfo.tres,n_chains,1);
mcmcInfo = resample_chains_v5(mcmcInfo);    % "Expectation Step"                 

% get empirical transition and occupancy counts    
% mcmcInfo = get_empirical_counts_v3(mcmcInfo); 

% calculate updated logL
mcmcInfo = calculateLogLikelihood(mcmcInfo);

loss = mean(mcmcInfo.logL_vec(mcmcInfo.step,:));

mcmcInfo.step = mcmcInfo.step + 1;