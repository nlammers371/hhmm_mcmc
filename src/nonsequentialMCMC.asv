% Script to experiment with non-sequential MCMC sampling for parameter
% inference

clear 
close all

addpath('utilities')

% define parameters
R = [-.02, .04, 0; .02 -.05 .08; 0 .01 -.08];
tres = 20;
A = expm(R*tres);
nStates = size(A,1);
v = [.05,2,4];
seq_length = 60*60/tres;
nSteps = 7;
[V, D] = eig(A);
[~, mi] = max(real(diag(D)));
pi0 = V(:,mi)/sum(V(:,mi));
noise = 1;
alpha = 1.4;
n_traces = 10;
eps = 1e-2;

emissions_cell = cell(1,n_traces);
master_sim_struct = struct;
for i = 1:n_traces
    synthetic_data = synthetic_prob(seq_length, alpha, nStates, nSteps, A, ...
                                                            v, noise, pi0);                                     
    emissions_cell{i} = v(synthetic_data.naive_states);
    
    % record full simulation info
    fieldNames = fieldnames(synthetic_data);
    for f = 1:length(fieldNames)
        master_sim_struct(i).(fieldNames{f}) = synthetic_data.(fieldNames{f});
    end
end

%% Gibbs MCMC 

% basic inference params 
n_steps = 100; % number of MCMC steps (need to add convergence criteria)

% initialize arrays
logL_vec = NaN(n_steps,1);
A_inf_array = NaN(nStates,nStates,n_steps);
v_inf_array = NaN(nStates,n_steps);

% specify hyperparameters

% A prior--assume strongly diagonal PDF given short timescale
% take A columns to follow multinomial Dirichlet distribution
A_alpha = ones(nStates);%*n_particles*n_traces;
A_alpha(eye(nStates)==1) = A_alpha(eye(nStates)==1)*10; % distribution hyper params

% emission rate priors. For now assume v_i's to be Poisson. Thus, the
% conjugate prior is gamma distributed
v_prior = v; % prior on RNAP initiation rates


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% initialize variables
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
A_curr = sample_A_dirichlet(A_alpha, zeros(nStates));
v_curr = v;

% calculate pi0 
[V, D] = eig(A_curr);
[~, mi] = max(real(diag(D)));
pi0_curr = V(:,mi)/sum(V(:,mi));

% initialize chains
[fwd_probs, logL_seq, logL_curr] = fwd_algorithm(emissions_cell, A_curr, v_curr, pi0_curr);

% record
logL_vec(1) = logL_curr;
A_inf_array(:,:,1) = A_curr;
v_inf_array(:,1) = v_curr;

step = 2;
deltaL = Inf;