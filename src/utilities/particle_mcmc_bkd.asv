function [pi_cell] = particle_mcmc_bkd(n_particles,emissions_cell, A_curr, v_curr, pi0_curr)

% take transpose of transition prob array
A_curr = A_curr';
% initialize shit
K = size(A_curr,1);
A_tracker_array = NaN(K,K,numel(emissions_cell));
pi_cell = cell(1,numel(emissions_cell));
% iterate through traces
for e = 1:numel(emissions_cell)     
    init_vec = emissions_cell{e};
    T = numel(init_vec);
    % array to store particle states    
    pt_array = zeros(n_particles,T);   
    occ_array = zeros(K,T);
    % index vector for sampling
    index_vec = 1:n_particles;
    %%%% initial state
    % sample initial state
    init_prop_vec = randsample(1:K,n_particles,true,pi0_curr);    
    % resample
    % record state occupancy
    pt_array(:,T) = init_prop_vec;
    for k = 1:K
        occ_array(k,1) = sum(pt_array(:,T)==k);
    end    
    %%%% iteration through time points
    for n = fliplr(1:T-1)
        % simulate transitions
        A_array = cumsum(A_curr(:,pt_array(:,n-1)));
        rand_array = repmat(rand(1,n_particles),K,1);
        state_vec_prop = sum(rand_array > A_array) + 1;
        for k = 1:K
            occ_array(k,n) = sum(init_prop_vec==k);
        end
        % resample
        emit_probs = poisspdf(init_vec(n+1),v_curr(state_vec_prop));
        rs_indices = randsample(index_vec,numel(index_vec),true,emit_probs);         
        pt_array(:,n) = state_prop_vec(rs_indices);
    end     
    % record         
    pi_array = NaN(K,size(pt_array,2));
    for k = 1:K
        pi_array(k,:) = sum(pt_array == k);
    end
    pi_array = pi_array ./ size(pt_array,1);
    pi_cell{e} = pi_array;   
    prob_cell{e} = prob_array;
    %%% now check implied "A" and "v" values for consistency
    % v first   
    for k = 1:K
        v_cts(k,e) = sum((sum(pt_array==k) .* init_vec));
        v_wts(k,e) = sum(pt_array(:)==k);
    end
    % now A
    A_tracker_array(:,:,e) = A_tracker;        
end
% extract values
A_count = sum(A_tracker_array,3);
v_wts_out = sum(v_wts,2);
v_cts_out = sum(v_cts,2);